import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:meta/meta.dart';
import 'package:path/path.dart' as path;
import 'package:yaml/yaml.dart';

String guessPubCacheDir() {
  var pubCache = Platform.environment['PUB_CACHE'];
  if (pubCache != null && Directory(pubCache).existsSync())
    return pubCache;

  if (Platform.isWindows) {
    pubCache = path.join(Platform.environment['APPDATA'], 'Pub', 'Cache');
    if (pubCache != null && Directory(pubCache).existsSync())
      return pubCache;
    pubCache = path.join(Platform.environment['LOCALAPPDATA'], 'Pub', 'Cache');
    if (pubCache != null && Directory(pubCache).existsSync())
      return pubCache;
  }

  final homeDir = Platform.environment['HOME'] ?? Platform.environment['USERPROFILE'];
  pubCache = path.join(homeDir, '.pub-cache');
  return pubCache;
}

final flutterDir = Platform.environment['FLUTTER_ROOT'];
final pubCacheDirPath = guessPubCacheDir();

main(List<String> args) async {
  try {
    if (flutterDir == null) {
      print('FLUTTER_ROOT is not set.');
      return 1;
    } else if (pubCacheDirPath == null) {
      print('Could not determine PUB_CACHE directory.');
      return 2;
    } else if (args.length == 1 && (args[0] == '--help' || args[0] == '-h')) {
      print('Usage: generate.dart [OUTPUT_FILE_PATH [PROJECT_ROOT]]');
      return 3;
    }

    final projectRoot = args.length >= 2 ? args[1] : await findProjectRoot();
    final outputFilePath = args.length >= 1 ? args[0] : path.join(projectRoot, 'lib', 'oss_licenses.dart');
    final licenses = await generateLicenseFile(projectRoot: projectRoot);

    final dartCode = '''/// This code was generated by flutter_oss_licenses
/// https://pub.dev/packages/flutter_oss_licenses
final ossLicenses = <String, dynamic>''' + jsonEncode(licenses) + ';';

    await File(outputFilePath).writeAsString(dartCode);
    return 0;
  } catch (e, s) {
    print('$e: $s');
    return 4;
  }
}

Future<Map<String, dynamic>> generateLicenseFile({@required String projectRoot}) async {
  final pubspec = loadYaml(await File(path.join(projectRoot, 'pubspec.lock')).readAsString());
  final packages = pubspec['packages'] as Map;

  final json = <String, dynamic>{};

  for (String name in packages.keys) {
    final package = await Package.fromMap(name, packages[name]);
    if (package == null || package.name == null) {
      continue;
    }

    json[name] = {
      'name': package.name,
      'description': package.description,
      'homepage': package.homepage,
      'authors': package.authors,
      'version': package.version,
      'license': package.license,
      'isMarkdown': package.isMarkdown,
      'isSdk': package.isSdk,
      'isDirectDependency': package.isDirectDependency
    };
  }
  return json;
}

Future<String> loadLicense({String name, String licenseFilePath, String defaultLicenseText}) async {
    String license = defaultLicenseText;
    try {
      license = await File(licenseFilePath).readAsString();
    } catch (e) {
      // ignore
    }
    return '//\n// $name\n//\n\'$name\': \'\'\'$license\'\'\',\n';
}

class Package {
  final Directory directory;
  final Map packageYaml;
  final String name;
  final String description;
  final String homepage;
  final List<String> authors;
  final String version;
  final String license;
  final bool isMarkdown;
  final bool isSdk;
  final bool isDirectDependency;

  Package({this.directory, this.packageYaml, this.name, this.description, this.homepage, this.authors, this.version, this.license, this.isMarkdown, this.isSdk, this.isDirectDependency});

  static Future<Package> fromMap(String outerName, Map packageJson) async {
    Directory directory;
    bool isSdk = false;
    final source = packageJson['source'];
    final descs = packageJson['description'];
    if (source == 'hosted') {
      final host = removePrefix(descs['url']);
      final name = descs['name'];
      final version = packageJson['version'];
      directory = Directory(path.join(pubCacheDirPath, 'hosted/$host/$name-$version'));
    } else if (source == 'git') {
      final repo = gitRepoName(descs['url']);
      final commit = descs['resolved-ref'];
      directory = Directory(path.join(pubCacheDirPath, 'git/$repo-$commit'));
    } else if (source == 'sdk') {
      directory = Directory(path.join(flutterDir, 'packages', outerName));
      isSdk = true;
    } else {
      return null;
    }
    final isDirectDependency = packageJson['dependency'] == "direct main";

    String license;
    bool isMarkdown = false;
    if (outerName == 'flutter') {
      license = await File(path.join(flutterDir, 'LICENSE')).readAsString();
    } else {
      String licensePath = path.join(directory.path, 'LICENSE');
      try {
        license = await File(licensePath).readAsString();
      } catch (e) {
        try {
          license = await File(licensePath + '.md').readAsString();
          isMarkdown = true;
        } catch (e) {
        }
      }
    }

    if (license == null || license == '') {
      return null;
    }

    dynamic yaml;
    try {
      yaml = loadYaml(await File(path.join(directory.path, 'pubspec.yaml')).readAsString());
    } catch (e) {
      // yaml may not be there
      yaml = {};
    }

    if (yaml['description'] == null) {
      return null;
    }

    String version = yaml['version'];
    if (outerName == 'flutter') {
      version = await File(path.join(flutterDir, 'version')).readAsString();
    }
    if (version == null) {
      return null;
    }

    return Package(
      directory: directory,
      packageYaml: yaml,
      name: yaml['name'],
      description: yaml['description'],
      homepage: yaml['homepage'],
      authors: yaml['authors']?.cast<String>()?.toList() ?? (yaml['author'] != null ? [yaml['author']] : []),
      version: version?.trim(),
      license: license?.trim()?.replaceAll('\r\n', '\n'),
      isMarkdown: isMarkdown ?? false,
      isSdk: isSdk ?? false,
      isDirectDependency: isDirectDependency);
  }
}

String removePrefix(String url) {
  if (url.startsWith('https://')) return url.substring(8);
  if (url.startsWith('http://')) return url.substring(7); // are there any?
  return url;
}

String gitRepoName(String url) {
  final name = url.substring(url.lastIndexOf('/') + 1);
  return name.endsWith('.git') ? name.substring(0, name.length - 4) : name;
}

Future<String> findProjectRoot({Directory from}) async {
  from = from ?? Directory.current;
  if (await File(path.join(from.path, 'pubspec.yaml')).exists()) {
    return from.path;
  }
  return findProjectRoot(from: from.parent);
}
